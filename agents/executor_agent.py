"""
=============================================================================
EXECUTOR_AGENT.PY - Code Execution Agent
=============================================================================

This module contains the executor_agent, which is the FOURTH agent in the
multi-agent pipeline. Its job is to execute the Python code generated by
the code_writer_agent and capture the results.

ROLE IN THE PIPELINE:
--------------------
schema_agent → intent_agent → code_writer_agent → [EXECUTOR_AGENT] → narrative_agent → critic_agent

WHAT THIS AGENT DOES:
--------------------
1. Takes the generated code from state
2. Delegates to the python_executor tool to run the code
3. Captures the results (chart JSON, text output)
4. Updates state with the execution results

WHY SEPARATE THE AGENT FROM THE TOOL?
-------------------------------------
In LangGraph architecture, we distinguish between:

AGENTS: Nodes in the graph that make decisions and orchestrate work
TOOLS: Reusable functions that perform specific tasks

This separation provides several benefits:

1. REUSABILITY: The python_executor tool can be used by other agents
   or even other applications without being tied to LangGraph.

2. TESTABILITY: We can unit test the tool independently of the agent.
   Tool tests verify execution works; agent tests verify state updates.

3. CLEAN ARCHITECTURE: The agent handles state management, the tool
   handles execution logic. Each has a single responsibility.

4. FLEXIBILITY: We could swap out the execution tool (e.g., use a
   sandboxed executor) without changing the agent logic.

5. LOGGING/MONITORING: We can add observability at either level
   independently.

This agent is intentionally thin - it's a "wrapper" that connects
the graph's state management to the execution tool's functionality.

=============================================================================
"""

from state import AnalystState
from tools.python_executor import execute_code


def executor_agent(state: AnalystState) -> dict:
    """
    Execute the generated code and capture results.
    
    This agent is a thin wrapper around the python_executor tool.
    It extracts the necessary inputs from state, calls the tool,
    and formats the outputs for state updates.
    
    Parameters:
    -----------
    state : AnalystState
        The shared state dictionary. This agent reads from:
        - state["generated_code"]: The Python code to execute
        - state["csv_path"]: Path to the CSV file (passed to the code)
        
    Returns:
    --------
    dict
        A dictionary with updates to apply to the state:
        - "chart_json": The Plotly figure as JSON (or None if no chart)
        - "execution_result": Text output or error message
        
    Error Handling:
    --------------
    The tool handles errors internally and returns them as the
    execution_result. The agent passes through whatever the tool returns,
    allowing downstream agents (like critic) to detect and report errors.
    """
    
    # =========================================================================
    # STEP 1: Extract inputs from state
    # =========================================================================
    # We need:
    # - generated_code: The Python code written by code_writer_agent
    # - csv_path: The path to the data file (so the code can load it)
    #
    # The csv_path is passed into the execution namespace so that the
    # generated code can reference it when loading data.
    # =========================================================================
    
    generated_code = state["generated_code"]
    csv_path = state["csv_path"]
    
    # =========================================================================
    # STEP 2: Call the execution tool
    # =========================================================================
    # The execute_code function from python_executor.py:
    # 1. Sets up a controlled namespace with csv_path available
    # 2. Runs the code using Python's exec()
    # 3. Extracts the 'fig' variable and converts to JSON
    # 4. Extracts the 'result_text' variable
    # 5. Returns everything in a dict
    #
    # If execution fails, the tool catches the exception and returns
    # an error message as the execution_result.
    # =========================================================================
    
    execution_output = execute_code(generated_code, csv_path)
    
    # =========================================================================
    # STEP 3: Extract results from tool output
    # =========================================================================
    # The tool returns a dict with:
    # - chart_json: JSON string of Plotly figure (or None)
    # - execution_result: Text output or error message
    # - success: Boolean indicating if execution succeeded
    #
    # We pass through chart_json and execution_result to the state.
    # The success flag is implicit - if there's an error message in
    # execution_result, downstream agents will detect it.
    # =========================================================================
    
    chart_json = execution_output.get("chart_json")
    execution_result = execution_output.get("execution_result", "")
    
    # =========================================================================
    # STEP 4: Return state updates
    # =========================================================================
    # Both chart_json and execution_result will be:
    # - Used by narrative_agent to explain results
    # - Used by Streamlit to display the chart
    # - Used by critic_agent to evaluate success
    #
    # Note: chart_json might be None if the code only produced text output
    # or if execution failed. This is fine - not all analyses need charts.
    # =========================================================================
    
    return {
        "chart_json": chart_json,
        "execution_result": execution_result
    }


# =============================================================================
# WHY THIS THIN AGENT PATTERN IS COMMON
# =============================================================================
#
# You might wonder: "Why have this agent at all? Why not just call the tool
# directly from the graph?"
#
# In LangGraph, graph nodes must be functions with a specific signature
# (take state, return state updates). The tool has a different signature
# (takes code and csv_path, returns a result dict).
#
# The agent serves as an ADAPTER between:
# - The LangGraph state model (state dict in, state dict out)
# - The tool's interface (specific parameters in, specific results out)
#
# ADDITIONAL BENEFITS OF THE ADAPTER PATTERN:
#
# 1. STATE MAPPING: The agent decides what state fields to read and write.
#    If we renamed state fields, we'd only change the agent, not the tool.
#
# 2. PREPROCESSING: The agent could modify inputs before calling the tool
#    (e.g., add imports to the code, validate the code structure).
#
# 3. POSTPROCESSING: The agent could modify outputs after the tool returns
#    (e.g., truncate long results, add metadata).
#
# 4. MULTIPLE TOOLS: The agent could call multiple tools and combine results.
#
# 5. RETRY LOGIC: The agent could retry failed executions with modifications.
#
# For this simple case, the agent is minimal, but the pattern supports growth.
#
# =============================================================================
